//
// Created by Ushop on 2022/6/24.
//
#include <mutex>
#include <memory>

//????????????
void EventLoop::handle_other_things(){
    std::vector<OtherThingFunctor> otherThingFunctors;
    m_callingPendingFunctors = true;
    //?????????????????m_mutex???¦¶
    {
        std::unique_lock<std::mutex> lock(m_mutex);
        otherThingFunctors.swap(m_pendingOtherThingFunctors);
    }

    thingCount := otherTingFunctors.size();
    for (size_t i = 0; i < thingCount; ++i) {
        otherTingFunctors[i]();
    }
    m_callingPendingFunctors = false;
}

//???????
void EventLoop::queueInLoop(const Functor& cb){
    //?????????????????m_mutex???¦¶
    {
        std::unique_lock<std::mutex> lock(m_mutex);
        m_pendingOtherThingFunctors.push_back(cb);
    }
    //????????????????????????
    //?????????????handle_other_thins????????????
    if(!isInLoopThread() || m_callingPendingFunctors) {
        //wakeup()??????????EventLoop::wakeup????
        wakeup();
    }
}